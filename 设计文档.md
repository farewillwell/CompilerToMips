# 设计文档

众所周知一项比较大的工程需要你写一个设计的文档，这样才能体系化认识这个工程。

## 参考

hyggge的blog，[点击跳转](https://hyggge.github.io/2023/01/11/compile/compile-sysy-bian-yi-qi-she-ji)

顺便参考了crt的东西

## 架构

架构，看到学长们那么多的文件，决定采用软件包的形式完成，这部分以后再写

```
|---src
```

## 前端

首先我采取的是自顶向下的设计，需要对文法进行一定的非左递归转换

### lexer

### tokenList

之前一直在想怎么回溯和预读。

现在看来直接解析好所有token就行了，然后把这些东西都按照次序次序放到list里，轻松完成（

### parser

#### AST

如何实现一个简单的AST（abstract sysnex tree）？

##### 存什么

首先我们遇到的问题，就是一个节点里面，存什么？

例如：

```
ConstDecl ==> 'const' 'int' ConstDef { ',' ConstDef } ';' 
```

这个const,int ,;还用存吗？在实际操作的时候，是完全不用考虑这些东西的。

因此，我计划不存了，然后在输出的时候直接按照格式写的东西额外增加输出就好了。

一开始的token就是方便错误处理。根本不需要把一些没用的东西存到节点里面。

##### 初始化

初始化的时候，是先把东西都放好了再建类，还是建好类之后往里添加东西？

区别就是在添加多个东西的时候（不定长{}会导致直接把一个数组传进去，很伤）

总之，因地制宜。。

##### 父类节点

需要一个公共的东西，让上面那么多节点好存。

我不再设置父类节点有类似子节点的arraylist，这个应当根据不同的节点类型在其中的类中实现。

具体的每一个节点做什么，参照<重写文法>文档

##### parser调用依据

判定问题：在出现{},[]，|的时候，怎么知道该调用哪个呢？

看first集！

现在遇到了一个问题，就是：

```
ConstInitVal ==> ConstExp | '{' [ConstInitVal {',' ConstInitVal}]'}'
```

后面的，可能没有constInitVal怎么办？这个中括号会很难解决。

很简单，如果现在没有这个constInitVal，那么这个中括号就啥也没有了，所以后面就是一个右大括号，只需要判断这个就可以了。

这种前后括号照应的问题都可以通过类似的方式解决。

#### 预读

在stmt的时候，遇到了下面几种操作：

AssignStmt ==> LValExp '=' Exp ';'

GetIntStmt ==> LVal '=' 'getint''('')'';'

ExpStmt ==> [Exp] ';'

这三个的第一个东西都是非终结符

都会导致一去不回。

所以需要进行预读。

其中，exp实际上包括左值表达式：PrimaryExp ==> '(' Exp ')' | LValExp | Number

所以实际上是可能嵌套的。

注意，expStmt的时候不用parserStmt,需要在stmt里面专门开。

````c
Stmt ==> AssignStmt | ExpStmt | BlockStmt | IfStmt | WhileStmt | BreakStmt | CReturnStmt | GetIntStmt | PrintfStmt
AssignStmt ==> LValExp '=' Exp ';'
    //error h: LVal不可以是常量
    //error i: 可能缺少分号
ExpStmt ==> [Exp] ';'
    //error i: 可能缺少分号
BlockStmt ==> block （ 由于block的第一个是一个{，所以可以轻松判断这个
GetIntStmt ==> LVal '=' 'getint''('')'';'
    //error h: LVal不可以是常量
    //error i: 可能缺少分号
    //error j: 可能缺少右小括号
````

在解析Stmt的时候会出现一个问题——AssignStmt的产生式为`AssignStmt ==> LVal '=' Exp ';'`， GetIntStmt的产生式为`GetIntStmt ==> LVal '=' 'getint''('')'';'` ，ExpStmt的产生式为`ExpStmt ==> [Exp] ';'`。其中LVal和Exp是无法进行区分的，因此我们不能直接判断应该进入AssignStmt的分析子程序，还是进入GetIntStmt，还是进入ExpStmt的分析子程序。我采用的做法是——

- 先设置一个“监视点”，即记录下当前token流的指针位置，然后用Exp的分析子程序进行解析；
- 解析完之后，如果发现后面的token为`=`，说明此时应该解析的语法成分为AssignStmt或者GetIntStmt。然后进一步看看后面的token是否是`getint`，进一步判断是AssignStmt还是GetIntStmt。最后，将token流的指针恢复到“监视点”的位置，并使用AssignStmt或GetIntStmt的分析子程序重新进行解析；
- 如果后面没有`=`，则说明应该解析的语法成分正好为ExpStmt，不需要回溯，继续往后解析即可

问题很关键的一点是，ExpStmt可以不带stmt。这个需要特别判定一下。保证在进入特判的时候，必然是至少有个EXp的。

另外的是：

```java
UnaryExp ==> PrimaryExp | Ident '(' [FuncRealParams] ')' | UnaryOp UnaryExp
```

这个可以利用unaryOp的特性排除最后一个选择。

但是前两个该怎么办呢？两个都是有ident的情况的。

事实上，这个不用进行预读。

观察可以知道primary的frist有三个

(,LvalExp,Number

其中，LvalExp的是ident

综合起来就是,ident,(,IntConst(Number)的部分

另外的则是ident()的情况。

我们可以根据判断下一个token是不是（

所以有没有一种情况，让primaryExp后面接()呢？这应当是不可能的。

接（的只能是函数！

### 出现的bug

```java
public UnaryExp parserUnaryExp() {
    RW.TYPE type = ts.now().type;
    if (type == RW.TYPE.PLUS || type == RW.TYPE.MINU || type == RW.TYPE.NOT) {
        return new UnaryExp(parserUnaryOp(), parserUnaryExp(), 0, 0);
    } else if (ts.next().type == RW.TYPE.LPARENT) {
        TokenNode tokenNode = new TokenNode(ts.now(), 0, 0);
        ts.move(); // to (
        ts.move();// jump over ( ,to funcRealParams or  )
        if (ts.now().type == RW.TYPE.RPARENT) {
            ts.move();
            return new UnaryExp(tokenNode, 0, 0);
        } else {
            System.out.println("turn to do func "+ts.now().getContent());
            FuncRParams funcRParams = paserFuncRealParams();
            ts.checkError(RW.TYPE.RPARENT);
            ts.move();
            return new UnaryExp(tokenNode, funcRParams, 0, 0);
        }
    } else {
        return new UnaryExp(parserPrimaryExp(), 0, 0);
    }
}
```

```
PrimaryExp ==> '(' Exp ')' | LVal | Number
UnaryExp ==> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
```

问题的关键，在于这个unary该往哪里走？

能简单判断：

```
ts.next().type == RW.TYPE.LPARENT
```

就走ident func路线吗？

显然不能。

因为在(Exp)中，还有一个Exp也有()的情况。

问题的矛盾点就在于：

```
PrimaryExp | Ident '(' [FuncRParams] ')'
PrimaryExp ==> '(' Exp ')' | LVal | Number
LVal ==> Ident {'[' Exp ']'}
```

这两个如何分辨？

只需要判断当前的是不是括号就行了！

合并一下，就是：当前为ident且下一个为(，否则就是primary

也发现了，转化文法成非递归左文法，但是实际上自己输出的时候还是要按照原来的文法来

### 错误处理

| 错误类型                             | 错误类别码 | 解释                                                         | 对应文法及出错符号 ( … 表示省略该条规则后续部分)             |
| ------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 非法符号                             | a          | 格式字符串中出现非法字符报错行号为 **<FormatString>** 所在行数。 | <FormatString> → ‘“‘{<Char>}’”                               |
| 名字重定义                           | b          | 函数名或者变量名在**当前作用域**下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 **<Ident>** 所在行数。 | <ConstDef>→<Ident> … <VarDef>→<Ident> … <Ident> … <FuncDef>→<FuncType><Ident> … <FuncFParam> → <BType> <Ident> … |
| 未定义的名字                         | c          | 使用了未定义的标识符报错行号为 **<Ident>** 所在行数。        | <LVal>→<Ident> … <UnaryExp>→<Ident> …                        |
| 函数参数个数不匹配                   | d          | 函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的**函数名**所在行数。 | <UnaryExp>→<Ident>‘(’[FuncRParams ]‘)’                       |
| 函数参数类型不匹配                   | e          | 函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的**函数名**所在行数。 | <UnaryExp>→<Ident>‘(’[FuncRParams ]‘)’                       |
| 无返回值的函数存在不匹配的return语句 | f          | 报错行号为 **‘return’** 所在行号。                           | <Stmt>→‘return’ {‘[’Exp’]’}‘;’                               |
| 有返回值的函数缺少return语句         | g          | 只需要考虑函数末尾是否存在return语句，**无需考虑数据流**。报错行号为函数**结尾的’}’** 所在行号。 | <FuncDef> → <FuncType> <Ident> ‘(’ [<FuncFParams>] ‘)’ <Block> <MainFuncDef> → ‘int’ ‘main’ ‘(’ ‘)’ <Block> |
| 不能改变常量的值                     | h          | <LVal>为常量时，不能对其修改。报错行号为 **<LVal>** 所在行号。 | <Stmt>→<LVal>‘=’ <Exp>‘;’ <Stmt>→<LVal>‘=’ ‘getint’ ‘(’ ‘)’ ‘;’ |
| 缺少分号                             | i          | 报错行号为分号**前一个非终结符**所在行号。                   | <Stmt>,<ConstDecl>及<VarDecl>中的’;’                         |
| 缺少右小括号’)’                      | j          | 报错行号为右小括号**前一个非终结符**所在行号。               | 函数调用(<UnaryExp>)、函数定义(<FuncDef>)及<Stmt>中的’)’     |
| 缺少右中括号’]’                      | k          | 报错行号为右中括号**前一个非终结符**所在行号。               | 数组定义(<ConstDef>,<VarDef>,<FuncFParam>)和使用(<LVal>)中的’]’ |
| printf中格式字符与表达式个数不匹配   | l          | 报错行号为 **‘printf’** 所在行号。                           | <Stmt> →‘printf’‘(’<FormatString>{,<Exp>}’)’‘;’              |
| 在非循环块中使用break和continue语句  | m          | 报错行号为 **‘break’** 与 **’continue’** 所在行号。          | <Stmt>→‘break’‘;’ <Stmt>→‘continue’‘;’                       |

显然，分为两种错误：

- 语法错误
- 语义错误

#### 语法错误

| 缺少分号        | i    | 报错行号为分号**前一个非终结符**所在行号。     | <Stmt>,<ConstDecl>及<VarDecl>中的’;’                         |
| --------------- | ---- | ---------------------------------------------- | ------------------------------------------------------------ |
| 缺少右小括号’)’ | j    | 报错行号为右小括号**前一个非终结符**所在行号。 | 函数调用(<UnaryExp>)、函数定义(<FuncDef>)及<Stmt>中的’)’     |
| 缺少右中括号’]’ | k    | 报错行号为右中括号**前一个非终结符**所在行号。 | 数组定义(<ConstDef>,<VarDef>,<FuncFParam>)和使用(<LVal>)中的’]’ |

这些东西，在递归下降的时候就能处理。

错误 i，j，k 类型中的“前一个非终结符”强调的是在文法规则里出现在 `; ) ]` 之前的非终结符号，在分析中处理的是该非终结符产生的终结符号串的最后一个符号，也就是 `; ) ]` 本应该正常出现的位置的上一个单词

就是说，发现没有；的话，就自动找上一个token所在的行就行了

不过会发现，缺少的括号，让后面所有东西都向前移动了。

所以，我们只需要在对应列举的位置，把：

```java
//ts.checkError(RW.TYPE.RBRACK);
//ts.move();      
```

写成

```java
if (ts.now().type != RW.TYPE.RBRACK) {
    ec.addError(ts.lastTokenLineNum(), "k");
} else {
    ts.move();
}
```

这样就解决了语法问题



#### 语义错误

- a: <FormatString>，属于信息token，所以知道在哪一行            ok
- b: <Ident>，属于信息token，知道在哪一行         ok
- c: **<Ident>** ，属于信息token，知道在哪一行       ok
- d: 函数名，属于信息token
- e：函数名，~
- f：报错行号为 **‘return’** 所在行号，这个其实是不记录return的行号的，所以需要我们在节点里面单独记录
- g：报错行号为函数**结尾的’}’** 所在行号。这个也是不记录的，所以需要在节点里面单独记录
- h： **<LVal>** 所在行号，lval是一个非终结符，所以他定义的非终结符的行号应当是什么？不妨就按照ident的来，这个也不需要特殊存了
- I：报错行号为 **‘printf’** 所在行号。所以记录printf的行号即可     ok
- m：报错行号为 **‘break’** 与 **’continue’** 所在行号。所以记录这个行号即可。  ok

这样就结局了所有在parser中需要解决的东西，接下来只需要看符号表即可。

#### 符号表

问题是，符号表要在什么时候建立？

答案：在checkerror的时候建立，不用管以后的事情，就在checkerror的时候建立就行了。

#### 建表

符号表需要：函数的名字和var的名字可以重复

##### a

格式字符串中出现非法字符报错行号为 **<FormatString>** 所在行数。

在printStmt里面检查：

```java
private boolean checkStringCode() {
        String string = formatString.getContent();
        boolean formatError = false;
        for (int i = 0; i < string.length(); i++) {
            int value = string.charAt(i);
            if (value == 92 && i + 1 < string.length() && string.charAt(i + 1) != 'n') {
                formatError = true;
                break;
            }
            if (!(value == 32 || value == 33 || (value >= 40 && value <= 126))) {
                formatError = true;
                break;
            }
        }
        return formatError;
    }
```

##### b

函数名或者变量名在**当前作用域**下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 **<Ident>** 所在行数

设计重大问题：函数名定义和变量定义应该是分开的。

**在 SysY 中 不同作用域下局部变量可以和函数重名**

这个是bug之源！！！！！

只需要在

<ConstDef>→<Ident> …
<VarDef>→<Ident> … <Ident> …
<FuncDef>→<FuncType><Ident> …
<FuncFParam> → <BType> <Ident> …

这些里面查看即可；

```java
public void checkError(ErrorCollector errorCollector) {
        if (SymbolManager.SM.blockHasDefine(tokenNode.getContent())) {
            errorCollector.addError(tokenNode.getLine(), "b");
        }
    }
```

这个存在的问题是：

在函数形参里定义的东西，是算作下面一个block的，而不是和函数同级别的：

```java
int f1(int x){
    return x;
}

void f2(int x[])
{
    return;
}

int main() {
    int arr[2][2];
    f2(1);
    f1(f2(arr[0]));
    return 0;
}
```

所以不能在block的时候enterBlock，而应该在进入block前enter

所以需要遍历所有可能存在blockde

##### c

未定义，需要搜索所有当前能访问到的符号表

在符号表管理中：

```java
public boolean notDefineYet(String name) {
        for (int i = symbolTables.size() - 1; i >= 0; i--) {
            if (symbolTables.get(i).hasDefine(name)) {
                return false;
            }
        }
        return !globalSymbol.hasDefine(name);
    }
```

就可以实现逐个查找le

使用了未定义的标识符报错行号为 **<Ident>** 所在行数。

<LVal>→<Ident> …
<UnaryExp>→<Ident> …

```java
public void checkError(ErrorCollector errorCollector) {
        super.checkError(errorCollector);
        assert tokenNode != null;
        if (mode == 2 && SymbolManager.SM.notDefineYet(tokenNode.getContent())) {
            errorCollector.addError(tokenNode.getLine(), "c");
        }
    }
```

所以实际上，要修改这个notDefine的定义,因为可能定义函数乐但是没有定义变量，所以会导致错误

需要两个函数：

```java
 public boolean notDefineVarYet(String name) {
        for (int i = symbolTables.size() - 1; i >= 0; i--) {
            if (symbolTables.get(i).hasVarDefine(name)) {
                return false;
            }
        }
        return !globalSymbol.hasVarDefine(name);
    }

    public boolean notDefineFuncYet(String name) {
        for (int i = symbolTables.size() - 1; i >= 0; i--) {
            if (symbolTables.get(i).hasFuncDefine(name)) {
                return false;
            }
        }
        return !globalSymbol.hasFuncDefine(name);
    }
```

分别在Lvalue和unaryExp里面

```java
if (mode == 2 && SymbolManager.SM.notDefineFuncYet(tokenNode.getContent())) {
            errorCollector.addError(tokenNode.getLine(), "c");
        }
```

##### d

函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的**函数名**所在行数。

只需要在unary的时候查一下就可：

```java
if (mode == 2 && !SymbolManager.SM.paraNumOk(tokenNode.getContent(), paraNum)) {
            errorCollector.addError(tokenNode.getLine(), "d");
        }
```

注意当找到的名字不是函数的时候，直接算作对，不报错，因为那个不认为是函数。

##### e

最难的一个，先看看定义的时候其维度：

```java
ConstDef ==> Indent {'[' ConstExp ']'} '=' ConstInitVal
VarDef  ==>  Ident {'['  ConstExp  ']'} ['='  InitVal]
```

也就是说，需要能计算constExp的能力

但是：

```java
ConstExp ==> AddExp
```

```java
LVal ==> Ident {'[' Exp ']'}
PrimaryExp ==> '(' Exp ')' | LVal | Number
UnaryExp ==> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
MulExp ==> UnaryExp {('*' | '/' | '%') UnaryExp}  //注意归约
AddExp ==> MulExp {('+' | '-') MulExp} //注意归约
```

所以需要对这些东西提供计算的能力:

同时在ConstExp中使用的Ident 必须是常量，这个不设置bug，可以默认成功

因此：

LVal ==> Ident {'[' Exp ']'}中的ldent是常数，例如const a【10】，取a[2]也是正确的

但是a[10]的值究竟是多少，还要查符号表

 所以我们不妨先设计好怎么整符号表

如何知道这个数组的第二维？

```
b[10][10];
int func(int x[][10])
{

}
func(b)
```

那么这个10如何对上？

定义变量的dim：0，变量，1一维数组，大于2，二维数组，m-2=第二维

##### f

难点在于return其实存在block里面，而这个对应的return在block的returnstmt语句里面

```java
  public int getReturnLine() {
        return returnLine;
    }
```

而搜索所有语句：

```java
public int intReturnLine() {
        for (Node node : nodes) {
            if (node instanceof ReturnStmt&&((ReturnStmt) node).expNotNull()) {
                return ((ReturnStmt) node).getReturnLine();
            }
        }
        return -1;
    }
```

如果有是return的语句并且exp非空（有数字）

那么直接返回这个行

![image-20231018000702207](D:\A大三课程资料\编译\compiler\images\image-20231018000702207.png)

##### g

难点在于return存在的地方实在block里面，所以需要把函数写到block里

```java
if (this.funcType.getType() == RW.TYPE.INTTK && !this.block.hasReturn()) {
            errorCollector.addError(block.getRBraceLine(), "g");
        }
```

```java
public boolean hasReturn() {
        for (Node node : nodes) {
            if (node instanceof ReturnStmt) {
                return true;
            }
        }
        return false;
    }
```

##### h

<LVal>为常量时，不能对其修改。报错行号为 **<LVal>** 所在行号。

需要搜索赋值表达式和getint表达式，然后去查符号表，查看是不是var的变量

```java
ublic boolean identIsVar(TokenNode tokenNode)
    {
        String string = tokenNode.getContent();
        Symbol symbol=getSymbol(string);
        return symbol instanceof VarSymbol && !((VarSymbol) symbol).isConst;
    }
```

然后在assign和getint里使用一下：

```java
@Override
    public void checkError(ErrorCollector errorCollector) {
        super.checkError(errorCollector);
        if (!SymbolManager.SM.identIsVar(lVal.getTokenNode())) {
            errorCollector.addError(lVal.getTokenNode().getLine(), "h");
        }
    }
```

就可以了

但是，考虑到，int g(){}, g=10算作变量未定义，因此要修改这个逻辑

g作为左值的时候需要被查看是函数还是啥

```java
public boolean identIsVarButConst(TokenNode tokenNode) {
        String string = tokenNode.getContent();
        Symbol symbol = getSymbol(string);
        return symbol instanceof VarSymbol && ((VarSymbol) symbol).isConst;
    }
```

改为：

```java
 public void checkError(ErrorCollector errorCollector) {
        super.checkError(errorCollector);
        if (SymbolManager.SM.identIsVarButConst(lVal.getTokenNode())) {
            errorCollector.addError(lVal.getTokenNode().getLine(), "h");
        }
    }
```

即可

顺便注意。forstmt中也会出现这种情况，所以需要注意

##### l

printf中格式字符与表达式个数不匹配，报错行号为 **‘printf’** 所在行号。

也只需要在printf中完成即可

```java
private boolean checkStringParaNum() {
        String string = formatString.getContent();
        int sum = 0;
        for (int i = 0; i < string.length(); i++) {
            if (string.charAt(i) == '%' && string.charAt(i + 1) == 'd') {
                sum++;
            }
        }
        return sum == exps.size();
    }
```

##### m

在非循环块中使用break和continue语句  m  报错行号为 **‘break’** 与 **’continue’** 所在行号。

同理，

```java
public void checkError(ErrorCollector errorCollector) {
        super.checkError(errorCollector);
        if (SymbolManager.SM.notInLoop()) {
            errorCollector.addError(breakLine, "m");
        }
    }
```

这个需要看是不是在循环里面。

如何看？

对于一个ast来讲，在循环里，当且仅当当前子树存在一个父节点，其为forstmt

所以只要在check的时候，

```java
public void checkError(ErrorCollector errorCollector) {
        super.checkError(errorCollector);
        SymbolManager.SM.enterLoop();
    ///check
        SymbolManager.SM.exitLoop();
    }
```

即可

```java
public void enterLoop() {
        loopDepth++;
    }

    public void exitLoop() {
        loopDepth--;
    }
```

## 代码生成

### llvm_ir

我选择生成llvm_ir作为中间代码。

但是陷入了困局：生成这个东西，究竟是该如和做的？我觉得可以让节点来自己生成自己的代码，而不是针对性的每个类建一个自己的builder比较好

注意，toString只是目的，我们实际要操作的还是llvm的语法树，因此只需要设置tostring的方法。

### getIR的返回值

按照荣老师的c语言课程，我们可以知道，有的式子是在evaluate之后有值的 ，例如1+2，我们就需要在这个过程中吧中间的结果用value存下来，这样得到的就是一个新的%1，然后就可以在get之后去使用这个value了！！

但是假如没有，比如void函数，那么返回的就是一个null

或者比如jump的句子，返回的就是null

所以，我们的策略是，在一边生成的时候，一边把信息存起来，一边把名字分配给value。

若是多行类型的，那么则将最后一个式子的结果寄存器作为结果返回回去。

### 类型

#### basicBlock

我们知道，平时用大括号括起来的块，并不是基本块，所以我们需要知道基本块是如何构建的

#### user-def

这个所谓的user-def链究竟是啥，是不是代码优化的内容？

### 关于块

实际上，虽然块内部变量可以覆盖定义，但是在比如main里面，实际上套在块里面的是平级的，也就是说

```c
int a[4][4];
int main(){
    {
        int a=1;
        {
            int b=2;
        }
    }
    return  a[1][2]*2;
}
```

翻译过来也不过是

```llvm
@a = dso_local global [4 x [4 x i32]] zeroinitializer, align 16
; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 0, i32* %1, align 4
  store i32 1, i32* %2, align 4
  store i32 2, i32* %3, align 4
  %4 = load i32, i32* getelementptr inbounds ([4 x [4 x i32]], [4 x [4 x i32]]* @a, i64 0, i64 1, i64 2), align 8
  %5 = mul nsw i32 %4, 2
  ret i32 %5
}
```

实际上，一个块做到的，只不过是能够重用名字罢了。

其实我们只需要关心基本快就可以了

### 关于运算表达式

b=1+1；

这个就很简单了，直接能在开始的时候计算出来结果。

a=b+C

我如何记录这个b,c的结果？

可以令这个表达式的结果是一个value，然后我直接获取到这个getValue，就是那个局部变量名字。

#### add结构

我们思考一个问题

a\*b\*c*d

这样输出出来，应该是a的结果\*b的结果*c的结果。

应该有三个式子，但是实际上，我们这里就存了一个，应该怎么样转换？

或者说，是留到输出的时候转换，还是当场转换？

#### user参数

那么user的type是什么呢

#### 一个block的getIR的返回值是什么？

block显然不是一个句子，不是一个instr

一个尖锐的问题是，假如我选择使用一整个东西作为函数的操作数

，例如return 语句用a+b+c这个式子本身而不是其结果作为操作数，那么就和原本的语法内容好像没有什么区别了。但是输出的时候应当怎么做呢？怎么维持这些关系？

显然，我们需要在处理的时候把return都分在这个块里面，而不是作为return语句的子方法，然后在生成return语句的时候，我只需要返回这个上面结果持有的东西即可。

要摆脱原来的树型影响，不然干啥其实都没有意义了。

我应该做的是，把语句存到基本块里面，而不是存到一个return什么的指令里面。return指令只需要存最后结果的那个value就行了。

是的，事实上，使用，就该是直接的。

也就是说，我们的getIRCode，有两种功能，一方面是生成语句，放到对应的标准块中，另一种，则是获取上一个语句的值，然后作用到下一次语句中。

因此，要明确的一个事情是，千万不要把语句本身作为返回值返回，一定要是语句的结果，就是方法getAns()

然后加语句的时候直接加到IRB里面就好了，然后（有必要的话），把结果返回值传回来就可以。

### 一个首当其冲的问题是，符号表存什么？

存名字和value，其他不用存的，value都已经把信息存好了。

注意一个问题，我在测试的时候发现：

```c
int c=3*(b+ -+-+-+-+-+-10);
int main(){
  int d=4+c;
  int e=5*d;
  {
    int d=a+5;
    int c=c*2;
    d=b;
    int f=20;
    e=e+a*20;
  }
```

这个c=c*2，后面引用的c显然是全局的c，但是在我设计的时候已经被现在声明的c所替代了。

所以我可以换一个顺序，等声明结束之后再放到符号表里面。

### 关于全局变量和局部变量

之前觉得全局变量和局部变量没啥区别，现在意识到了。

main也是一个函数。其他外面定义的全叫全局。

全局的=叫initalize，局部的叫assign，是先申请然后赋值。这些东西是完全不一样的。

local在符号表里怎么存，那个value是啥？

事localvar。localvar是啥？事返回的一个数还是一个地址？我倾向就叫做地址就好了。当然如果是全局变量的话，输出的时候就是 int32* @ a什么的，还是比较容易输出的。

### ssa

ssa是个很有意思的东西，在

```c
int a=10;
   int b;
   b=a+1;
   return b;
```

中我发现，翻译后的ll文件时

```ll
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 0, i32* %1, align 4
  store i32 10, i32* %2, align 4
  %4 = load i32, i32* %2, align 4
  %5 = add nsw i32 %4, 1
  store i32 %5, i32* %3, align 4
  %6 = load i32, i32* %3, align 4
  ret i32 %6
```

很神奇，分配了三组地址，之后也没有用到，为什么，不理解

但是我发现要是把clang编译的那个%1去掉的话，结果就会十分的难以理解。

但是考虑到load指令一般只会load出来一个数字，而非数组，则处理的时候默认都是取出的整数。

显然，给变量分配的东西始终是一直存在在那个地址的。因此在进行赋值语句的时候，要先取出来地址，然后生成一个store语句，将值和地址存进去。

### 左值问题

lval有两种存在，一种是作为右边的东西：

```
int a =b+2;
```

这个时候，b的部分就应该是： load value from 指针,add value and 2 ，store it in a指针

但是，赋值的时候呢，这个a作为左值取回来的东西，就是取得getIR，又成了load出来的值了。

所以，一个lval应该有两种方式存这些生成的种类。

### 函数参数

##### 定义域问题

在函数的参数中，定义域应当是属于函数的，因此，在定义para之前，要先设置各个builder为进入到这个函数的状态。

如何解决函数参数实际上是在外一层定义的这个问题？

考虑到最多只有一层函数，所以我们单独可以建一个para符号表。

这样的话就不和block相冲突，导致设计的时候只有block进去才创建符号表。

但是，为了让逻辑严谨，我没有选择这么做，而是选择直接更改block的进入逻辑。

原本我是在block的时候直接进入。

但是现在经过修改，我改为了从func和blockstmt的时候进入，这样可以有效的进行para的定义。

##### 存取问题

在mips传递参数的过程中，是依靠那些v0寄存器。但是全用的这个寄存器，因此，在传进来之后就需要立即新开一些变量把这些东西存起来，不然就会导致寄存器的内容在后续的函数引用函数中丢失，从而失去内容。

所以，定义para的策略其实和localVal差不多。

### 数组处理

就是指令gep

[看看这个]: https://buaa-se-compiling.github.io/miniSysY-tutorial/lab7/help.html

这里先按照全局与否都一样（全局的话会存在压缩，但是局部好像没有压缩，我是按照局部的那种来的）

假如不是全局变量的话，会有如下形式：

```c
dou_a[1][1];
```

转化成

```
%7 = getelementptr inbounds [2 x [2 x i32]], [2 x [2 x i32]]* %3, i64 0, i64 1
 %8 = getelementptr inbounds [2 x i32], [2 x i32]* %7, i64 0, i64 1
```

因此这个不是一起的。是分开的。而且每个都要偏移一个从0开始的。

```
a[1]
```

解读：

```c
 %7 = getelementptr inbounds [10 x i32], [10 x i32]* %2, i64 0, i64 1
```

这个其实是一个套了一层的指令。

inbound后面的类型是和传进来的指针唯一绑定的。

GEP 指令的最基本语法为 `<result> = getelementptr <ty>, <ty>* <ptrval>, {<ty> <index>}*`，其中第一个 `<ty>` 表示第一个索引所指向的类型，第二个 `<ty>` 表示后面的指针基址 `<ptrval>` 的类型，`<ty> <index>` 表示一组索引的类型和值

`inbounds [10 x i32]`，这个是索引指向的类型。

而符号表中这个名字的类型：`[10 x i32]* %2`，事实上，它就是所谓的指针基址。例如a\[10][10],的指针基址类型就是int(*)[]\[10]

然后第一个i64=0是从这个指针的偏移，就是从这个[10 x i32]* %2的偏移，如果是i64 1的话那么偏移量是这个数组本身的大小。

注意，在符号表里，名字都是一个对象的指针，或者i32对象，或者【10】对象，那么这个名字对应的就是一个[10]的指针，就是*[10]

第一个索引不会改变返回的指针的类型，也就是说 `ptrval` 前面的 `<ty>*` 对应什么类型，返回就是什么类型；第一个索引的偏移量的是由第一个索引的值和第一个 `ty` 指定的基本类型共同确定的。

[i32X 10] ,[i32X10]*%1,i32 0, i321

第一个0代表又%1这个指针的偏移，对应的的对象是[i32X10]，如果后面没有i32 1的话那么返回的还是[i32 X10]的指针

但是加上了i32 1后，取得对象就是 [i32 X10]中得[1]对象了，然后返回的是这个对象的指针。

这样也说明了为什么不能

```
%V2 = getelementptr inbounds i32*, i32** %V1,  i32 0 ,i32 0
```

，因为 i32*根本不是一个对象组

#### ptr

分析一下这个指令可能出现的情况：

（1）直接取一个数的值，例如a，取a的值，a里面存的东西是指针，从里面load

（2）取一个数组中的元素，例如a[10],取a[1]，那么就要找到a[1]的指针，而a本身分明是数组的指针int (*)[]，所以要先偏移个0找到数组，然后再取其中的元素

（3）在参数中传进来一个指针，比如int a[],比如int a[]\[3]，这些都是指针，也就是说a这个指针指向的不是数组，而是一个指针。

显然无法从数组中提取元素。

所以我们需要让gep分别能执行指针的功能和数组的功能。数组的功能还是很容易实现的，就看指针的了

### 构造gep-load-store指令体系

如何统一的构成这个的体系？

原本的lval，我设置了一个方法，叫

```java
// TODO 这个方法是上面说的需要作为被赋值的码,但是其实好像不需要，直接放到store里面就好了

    public Value getIRAsLeft() {
        VarSymbol varSymbol = SymbolManager.SM.getVarSymbol(tokenNode.content());
        return varSymbol.value;
    }

```

但是事实上，这个只在assign和getint的store的时候使用了。

因此我觉得这个方法似乎没啥用，所以我删了，把需要赋值情况的东西专门处理。

让load和store都是直接操作value，才是统一的。

显然，gep是可以满足多维数组一次取用的，所以如果有必要，需要设置多个index的存取方法。

但是，在生成mips的时候，计算指令就会变得复杂不少。

但是我打算用c语言的视角，数组的元素是一维数组，而不是破坏这个。

所以只对getptr指令设置一维的操作。

### 参数与gep

但是在处理参数的时候，我遇到了较大的困境

关于exp=0；

```java
if (exps.size() == 0) {
            // TODO 如果是单个变量的话，直接正常取出来就好了。
            // TODO 但是等于0 不代表是单个变量，也有可能是一个完全没取过index的数组
            // 所以这个情况完全没必要考虑    
            LoadInstr loadInstr = new LoadInstr(varStorePointer);
            IRBuilder.IB.addInstrForBlock(loadInstr);
            return loadInstr.getAns();
        }
```

当然也有可能是单纯要返回一个二维数组作为参数，因此不能用这个判断。

## 条件分支

首先，cond的最外层一定是lor，并且lor一定仅出现在最外层。
因此，cond的结构一定是

若干个and相或，然后在and里面若干个eq相与，然后eq以下都认为是在进行icmp的计算求值。

### 如何求cond的值

问题的矛盾集中在eq和rel这两种里。

### if语句

如何构造if语句？

```
Stmt    → 'if' '(' Cond ')' Stmt1 [ 'else' Stmt2 ]  (BasicBlock3)
```

![image-20231113163348906](D:\A大三课程资料\编译\Compile_mips\images\image-20231113163348906.png)

br指令的特点，要不是直接就无条件跳，要么就根据cond的值判断一个要跳到得地方。反正必须要跳的。

无条件跳，我可以设计成jump直接跳。

有条件跳，那就是branch指令。

这里我参考了hyggge的一个神奇操作：

问题在于：if，else整完了之后，剩下的指令呢？

```c
if(a>0)
    {
        a=1;
    }
    else
    {
        a=2;
    }
    a=3;
```

cond里面会写的是，如果生效，跳到then块，否则跳到else块。

```
cond:
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %7
if:
6:                                                ; preds = %0
  store i32 1, i32* %2, align 4
  br label %8
else:
7:                                                ; preds = %0
  store i32 2, i32* %2, align 4
  br label %8

finally:
8:                                                ; preds = %7, %6
  store i32 3, i32* %2, align 4
  ret i32 0
```

我们可以看到职责划分里面，cond只需要能够跳到if和else块里面就行了，而跳到finally块是if和else块本身做的，而且是直接跳转

### 循环

初始化部分直接原地建就行，没啥区别

我们知道，if的时候，cond直接原地生成就行了。因为if判断完之后，就直接走了。

但是每次循环跳回来的时候，还要读cond，所以cond值得单独开一个basicBlock。

同时，每次执行完循环还要单独做一个操作loopEndInstr。

考虑到循环的层次问题，（n重循环往哪里跳），线性的处理显然是不可以的，不然就不知道break是从哪里来的了。

所以我们需要在irbuilder里面建一个loop栈。

loop要存的：cond的block，loopEndInstr的block，loop循环体的block，loop结束后的block

而且需要考虑在语法中，这几项为空的情况。

当然，这几项即使为空，该建立的块也要建立，加上br就好了。

在这里，cond的then，就是循环体块，它的else，就是loop结束后的block

## 艰难的debug

无return问题

有时候，void函数没有return，这就会导致错误

```
b4:
}
```

因此，在结束的时候，一定要检查一下是否在最后一条语句种有return，没有的需要补一下。
