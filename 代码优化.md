# 代码优化

竞速排序最后一个点t了。。

必须优化了这下。。

## 乘除优化

### 常数优化：将常数的运算全算出来

#### 在哪里优化？

### 变量和常量计算

如果对于一个乘法mulExp，，其factor序列为a1,a2...an若前ai个均为常数，则这前ai个可以化简为一个常数

如果其中有一个0，则整个就是0

### 乘法优化

#### constant - constant

不生成指令，直接计算出来结果之后存到相应内存中

包括其他指令在内也一样

#### constant - x

通过shift比较计算

#### x - x

老老实实算吧

#### 除法优化

如果除的数是常数且为2的幂次，可以转化为sll

## CFG

首先解决的是跳转问题

比如在

```
if(a>1)
{
 b=b+1;
 return 0;
}
```

这个代码中，我会生成:

```
b1:
  ret i32 1
  br label %b3
b2:
  ret i32 2
  br label %b3
```

这种形式的，这显然是会错误估计支配边界的。

因此，我们做一个检查，对于一个block，如果遇到了一个离开指令，那么删除后面所有的代码。

### mem2reg

对于全局变量，我们不做这个优化。我们的 mem2reg 只需要对局部的 `int` 类型的变量进行处理

而一定要排除其他的干扰，不然会出现很多错误，比如在计算前提前删除所有流图上不可达到的指令

![image-20231129133150807](D:\A大三课程资料\编译\Compile_mips\images\image-20231129133150807.png)

现在来理解下这个算法：

F是做了一个记录，记录哪些已经插过phi了，一个块对一个变量插一个就好了

假定defs(v)是所有定义了变量v的块。这个和初始的W是一个意思

W是所有定义(修改该值）的块，加上后代表目前还没有考虑到这个

接下来对于所有修改该值的块，如果还有没有考虑到的，那么就开始考虑这个，同时从W中移除

对于这个块的所有支配边界，这个变量的值可能会被其他块的这个量影响，所以要插phi(这个phi的来源值是？)，同时标记这个块已经被这个变量插过了。当然，phi指令本身就是一个对变量赋值的，所以插入后这个指令也要算作defs(v)的，就是w

**注意，虽然可能一个块没有涉及到一个变量，但是经过它的后续都有可能涉及到这个变量，所以插入phi是理所当然的**。

刚才我们已经完成了df的求解，得到了每一个块的支配边界。但是注意，我们仅仅完成了块的。

和变量有关的是一点没碰啊。。。

同时，发现这里很多东西都是跨块的。如果再把一堆东西都放到函数里面，就太复杂了，这个功能单独拿出来执行即可。

注意，重命名，什么的都是针对的变量，这个变量不是llvmValue，就是不是%那个东西，而是在源程序里的那个 int a什么的

(数组在每个位置上的使用，难以分析，我们选择只分析单一变量，也就是说正常alloca数组)

而int a这样的localVar会在什么地方被声明呢？显然就是alloca那里。在什么地方定义呢？有=就算，就是store

### 算法实现

W用什么数据结构？每次单独拿一个出来？用Linklist不错

Y插入v的phi，那么来源是什么？我怎么知道是哪些基本块？

一开始是不知道的，所以需要先存起来。

### 功能构成

这里还要再在func里面把功能教给func吗？我觉得直接把东西专门拿出来到一个类里面实现是比较好的

alloca ： 代表一个变量(不define)

load : use值，add什么的算use吗，算，但是都需要load专门拿出来，因此load是必须的。

store : define 值

### 变量重命名

什么叫reachingDef? 就是一个变量在这里，它所代表的值。

比如store 一个值x进到一个指针，这个指针代表变量a，那么这里它的到达定义就是x了，把所有从a里store都算作load即可

激动人心的时刻来了！！

![](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150734468.png)

更新到达定义，v是变量，i是指令。

(in-place，原地)

沿着v的定义链搜索，知道我们找到了最近的支配i的定义，然后用这个定义更新v的到达定义

先用将当前的到达定义赋值给r，当r的定义不支配语句i的时候

![image-20231129150035982](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150035982.png)



注意，更换value的时候，要记得把其中的user关系更换。

### bug

phi缺元素问题

```
PHINode should have one entry for each predecessor of its parent basic block!
  %V45 = phi i32 [ %V44, %b3 ]
```

比如上面这个

问题在于phi插是插了，但是填写的不够全.

```java
for (BasicBlock next : block.next) {
            for (Instr instr : next.instrList) {
                if (instr instanceof PhiInstr) {
                    if (!reachDefs.containsKey(((PhiInstr) instr).tieValue)) {
                        continue;
                    }
                    if (reachDefs.get(((PhiInstr) instr).tieValue).empty()) {
                        continue;
                    }
                    Value newValue = reachDefs.get(((PhiInstr) instr).tieValue).peek();
                    ((PhiInstr) instr).refill(newValue, block);
                }
            }
        }
```

我们回填的逻辑是，由于回填phi是对每一个的后继节点的phi进行回填，所以每一个phi，会被其cfg上的父块唯一的访问一次，所以无论当前父块有无这个变量的定义，都需要对其填写(如果没有遇到那么就填写为0就好了，反正也不可能到达)

### "提前引用"的变量

考虑到我们设置phi是按照程序流图的方向，而不是按照块的顺序，我们可能会在list前面的块用到了后面才会定义的东西。

所以我们在进行mips指令生成前，需要先对所有指令的getAns进行内存的分配。

### 新增变量命名问题：

在优化时，默认在main里面。但是别忘了优化可是对所有函数负责的。

因此新插入phi的时候可能会重复命名变量

解决:记录所有函数的变量到了第几个数了。进入这个函数优化的时候把localcnt拿回来继续之前的计数即可

## 消phi

phi，代表了，从哪里来，值该是多少。同时有性质：如果一个块有phi，那么phi指令一定是在所有指令的最开始

一开始设想的是记录一下来自哪个块，然后switch。

但是发现有更容易的：那个来自的块最后(当然，指跳转前)给这个变量附上相应的值就可以。

但是如果这个from块，可能跳到不一样的后继(事实上，最多俩，branch 或者jump)，这些不一样的后继可能出现不一样的情况。如果两个分支统一在branch块里解决可能会出问题。因为我实际上并不需要在去往这个块里给这个变量赋值。虽然事实上我的设计可以保证如果是在branch块，它的两个分支里面是不会有phi的，但是以防万一，还是把情况都预备上为好.

因此，由于块A最后的指令只能为：jump，branch，ret三个指令，不考虑ret的情况，块A的转移无非两种情况：

第一种，如果jump到后继块B，那么直接在jump之前赋值即可，具体的赋值是搜索它后继的块(事实上可以直接通过jump找到)，找到来自它的phi指令，然后在A的后面对phi的getAns进行phcopy。它不需要增加辅助块。因此不需要设置修改目标块的操作。

phiCopy是个什么指令，它能存储多个吗？我觉得没有必要，反正是要拆开成move的。

第二，如果brachC或者d，那么检查自己的两个块的phi，看看是否有phi(如果有的话，根据phi的性质，必然存在一个来自A块的value，注意，如果是constant的话，需要检查一下是否是未定义，是的话直接赋值没有任何意义)。如果有，那么就新开一个块，更改指向关系，然后在这个新块里面插入pcopy指令。如果没有的话，当然就没有必要新开了

删除phi指令应该在什么时候执行呢？事实上，遍历函数所有块之后，我们就可以再过一遍块，把phi指令都删掉，只留下copy

### pcopy - > move

pcopy是一个并行的move，就像phi是一个并行的phi

但是phi的并行又是怎么样的呢？

## 初步GVN

目前只实现了GVN的简单步骤，首先是常量折叠，如果两个操作数都是常量，那么就删除这条指令，而把所有用这条指令ans的换成计算后的操作数

然后是跳转压缩，如果br的判断量是常量，那么将必然只有一方为可达到的，把br换成jump即可

## 初步死代码删除

考虑到经过上面的GVN，很多块其实是跳不到的，或者开了一个块仅仅是为了jump一下，没有什么意思。

所以把中间的部分优化掉，只剩下可达的，和必然达到的。

但是，有可能在删除一些块后，一些move指令用到了原有的块的内容，就会导致未定义，当然，既然达不到，那么用这个块内容的指令本身就是无效的，所以我们可以直接删掉这个move。实际上，使用这个move的值也应当删掉。

上面是两个非常激进的，可能会导致错误(因为最后的支配并没有更新，如果需要用的话，要再算一次)

## 寄存器分配

之前在mips生成的时候，为了方便，我一直用的是全部把数据存到内存中。

这样的效率是十分低下的。

所以，我们需要在适当的时候，使用寄存器分配。

看不懂教程的内容，我选择采用hyggge学长的办法

任务：

首先我们明确一个方针，一个%local变量必然对应一段内存,这个是在llvm分配阶段就已经分配好的了。不过，我们可以为了优化，在平时的时候选择把它的值暂存到寄存器里。当需要用到这个值的时候，我们首先查询它是否被寄存器存储，如果是，则可以直接调用。否则，需要给他开一个寄存器，把它从地址拿进来。如果没法没有代价的新开一个寄存器，则可以选择一个，然后把这个寄存器放到属于它的 内存中。

同时，应当在mips生成前把寄存器分配好了

溢出应当是非常罕见的情况，一般来说不可能活跃那么多变量的。

首先可以肯定的是，我们需要进行活跃变量分析。

假设我们已经进行了正确的活跃变量分析

需要确定的是，活跃变量分析是一个一脉相承的过程，in中有，代表这个变量在A之前生效，out没有，代表出了A，至少在A的支配树里，必然不存在了。因此可以暂时的在遍历它支配的东西的时候把这些变量删掉。

同时可以拓宽的思考，A的out是针对几个dom的，但是B的in这个东西是针对一个dom的，所以B的in里的东西比

A的out里的还少不少

思考，在转化代码的时候，我们的设计是在mips生成阶段,一开始就扫描一遍，为每个人alloc一个地址。这个地址应当是恒久不变的，而且平时也用不到。只有在寄存器溢出的时候才需要。那么实际上的寄存器呢?可以在varmanager里预设定一个值，那个就是该value将要被装进的reg,目前不和varsymbol耦合，只有当前值在寄存器的时候才存到varsymbol里面。

全局变量是不分配寄存器的,我们统一选择使用临时寄存器

### 定理：块A定义的必然仅会在块A的支配集合里面被用到

但是这个定义会不会出现重复赋值的情况?

答：会在循环里面重复赋值，但是在别的地方不会重复赋值，所以如果在一个地方产生的变量，那么必然只会在这里被定义

### 处理spill

效率问题：如果我是选择当前分配完寄存器的话，后续的都不使用寄存器，都直接从内存拿，拿到临时寄存器里，和每次发现没寄存器了，就把一个换回去，把现在的拿出来用，哪个效率更高?

前者的话，其操作是：

```
load
```

坏处是如果大量使用这个寄存器的话那么反而得不偿失，每次都拿一下，需要赋值的时候再放回去

后者的话，其操作其实是:

```
store // 把原本寄存器的存回去
load // 把这个值拿出来
```

好处是load出来的寄存器这段时间可以一直用

暂时选择前者。

后续可以做一下后者看看速度

### 处理zext

注意到，在mips里面其实是没有i1的。

所以在执行的时候我们需要按照i32存这个。

我们不需要特殊对待zext,这个指令就相当于move一样.

### call遗留问题

之前不论是不是void，都开了一个新的量，是愚笨的，撤销即可

### 寄存器分配问题

之前把a1-a3一视同仁,但是实际上考虑到传参的时候

这个函数的a1,a2,a3

传到后面的a2,a3,a1

就乱套了

所以不能在平时用a1a2a3存。

而函数参数存储对应关系

p1,p2...pn

mem1...memn

前三个额外有a1,a2,a3这三个寄存器用来传递

实际上,这mem1....memn都是在新函数栈底依次排列的

在call的时候

|旧sp     |新sp

​			ra|m1,m2,m3

把m4以后的参数直接存到他们的内存里面

m1,2,3直接放到a1,a2,a3里。

然后在进入到新的函数之后

首先i<=3必然会被分配寄存器

如果给参数pi分配寄存器了，如果i<=3，那么move * ai

否则mem * mi

如果没有分配寄存器,那么已经存到对应地址里面了,就不用管了

## 寄存器分配问题

发现了一个很复杂的bug

就是明明给这个变量分配寄存器了

但是它就不从哪里取，反而取那个对应地址去取了，就会乱套

原因是我遍历基本快的时候是按顺序,而不是按照支配树来的，但是分配寄存器的时候是没有考虑到这个的

所以就会出问题



