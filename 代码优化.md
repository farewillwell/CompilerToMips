# 代码优化

竞速排序最后一个点t了。。

必须优化了这下。。

## 乘除优化

### 常数优化：将常数的运算全算出来

#### 在哪里优化？

### 变量和常量计算

如果对于一个乘法mulExp，，其factor序列为a1,a2...an若前ai个均为常数，则这前ai个可以化简为一个常数

如果其中有一个0，则整个就是0

### 乘法优化

#### constant - constant

不生成指令，直接计算出来结果之后存到相应内存中

包括其他指令在内也一样

#### constant - x

通过shift比较计算

#### x - x

老老实实算吧

#### 除法优化

如果除的数是常数且为2的幂次，可以转化为sll

## CFG

首先解决的是跳转问题

比如在

```
if(a>1)
{
 b=b+1;
 return 0;
}
```

这个代码中，我会生成:

```
b1:
  ret i32 1
  br label %b3
b2:
  ret i32 2
  br label %b3
```

这种形式的，这显然是会错误估计支配边界的。

因此，我们做一个检查，对于一个block，如果遇到了一个离开指令，那么删除后面所有的代码。

### mem2reg

对于全局变量，我们不做这个优化。我们的 mem2reg 只需要对局部的 `int` 类型的变量进行处理

而一定要排除其他的干扰，不然会出现很多错误，比如在计算前提前删除所有流图上不可达到的指令

![image-20231129133150807](D:\A大三课程资料\编译\Compile_mips\images\image-20231129133150807.png)

现在来理解下这个算法：

F是做了一个记录，记录哪些已经插过phi了，一个块对一个变量插一个就好了

假定defs(v)是所有定义了变量v的块。这个和初始的W是一个意思

W是所有定义(修改该值）的块，加上后代表目前还没有考虑到这个

接下来对于所有修改该值的块，如果还有没有考虑到的，那么就开始考虑这个，同时从W中移除

对于这个块的所有支配边界，这个变量的值可能会被其他块的这个量影响，所以要插phi(这个phi的来源值是？)，同时标记这个块已经被这个变量插过了。当然，phi指令本身就是一个对变量赋值的，所以插入后这个指令也要算作defs(v)的，就是w

**注意，虽然可能一个块没有涉及到一个变量，但是经过它的后续都有可能涉及到这个变量，所以插入phi是理所当然的**。

刚才我们已经完成了df的求解，得到了每一个块的支配边界。但是注意，我们仅仅完成了块的。

和变量有关的是一点没碰啊。。。

同时，发现这里很多东西都是跨块的。如果再把一堆东西都放到函数里面，就太复杂了，这个功能单独拿出来执行即可。

注意，重命名，什么的都是针对的变量，这个变量不是llvmValue，就是不是%那个东西，而是在源程序里的那个 int a什么的

(数组在每个位置上的使用，难以分析，我们选择只分析单一变量，也就是说正常alloca数组)

而int a这样的localVar会在什么地方被声明呢？显然就是alloca那里。在什么地方定义呢？有=就算，就是store

### 算法实现

W用什么数据结构？每次单独拿一个出来？用Linklist不错

Y插入v的phi，那么来源是什么？我怎么知道是哪些基本块？

一开始是不知道的，所以需要先存起来。

### 功能构成

这里还要再在func里面把功能教给func吗？我觉得直接把东西专门拿出来到一个类里面实现是比较好的

alloca ： 代表一个变量(不define)

load : use值，add什么的算use吗，算，但是都需要load专门拿出来，因此load是必须的。

store : define 值

### 变量重命名

什么叫reachingDef? 就是一个变量在这里，它所代表的值。

比如store 一个值x进到一个指针，这个指针代表变量a，那么这里它的到达定义就是x了，把所有从a里store都算作load即可

激动人心的时刻来了！！

![](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150734468.png)

更新到达定义，v是变量，i是指令。

(in-place，原地)

沿着v的定义链搜索，知道我们找到了最近的支配i的定义，然后用这个定义更新v的到达定义

先用将当前的到达定义赋值给r，当r的定义不支配语句i的时候

![image-20231129150035982](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150035982.png)



注意，更换value的时候，要记得把其中的user关系更换。

### bug

phi缺元素问题

```
PHINode should have one entry for each predecessor of its parent basic block!
  %V45 = phi i32 [ %V44, %b3 ]
```

比如上面这个

问题在于phi插是插了，但是填写的不够全.

```java
for (BasicBlock next : block.next) {
            for (Instr instr : next.instrList) {
                if (instr instanceof PhiInstr) {
                    if (!reachDefs.containsKey(((PhiInstr) instr).tieValue)) {
                        continue;
                    }
                    if (reachDefs.get(((PhiInstr) instr).tieValue).empty()) {
                        continue;
                    }
                    Value newValue = reachDefs.get(((PhiInstr) instr).tieValue).peek();
                    ((PhiInstr) instr).refill(newValue, block);
                }
            }
        }
```

我们回填的逻辑是，由于回填phi是对每一个的后继节点的phi进行回填，所以每一个phi，会被其cfg上的父块唯一的访问一次，所以无论当前父块有无这个变量的定义，都需要对其填写(如果没有遇到那么就填写为0就好了，反正也不可能到达)

### "提前引用"的变量

考虑到我们设置phi是按照程序流图的方向，而不是按照块的顺序，我们可能会在前面的块用到了后面才会定义的东西。

所以我们在进行mips指令生成前，需要先对所有指令的getAns进行内存的分配。

### 新增变量命名问题：

在优化时，默认在main里面。但是别忘了优化可是对所有函数负责的。

因此新插入phi的时候可能会重复命名变量

解决:记录所有函数的变量到了第几个数了。进入这个函数优化的时候把localcnt拿回来继续之前的计数即可

## 消phi

phi，代表了，从哪里来，值该是多少。同时有性质：如果一个块有phi，那么phi指令一定是在所有指令的最开始

一开始设想的是记录一下来自哪个块，然后switch。

但是发现有更容易的：那个来自的块最后(当然，指跳转前)给这个变量附上相应的值就可以。

但是如果这个from块，可能跳到不一样的后继(事实上，最多俩，branch 或者jump)，这些不一样的后继可能出现不一样的情况。如果两个分支统一在branch块里解决可能会出问题。因为我实际上并不需要在去往这个块里给这个变量赋值。虽然事实上我的设计可以保证如果是在branch块，它的两个分支里面是不会有phi的，但是以防万一，还是把情况都预备上为好.

因此，由于块A最后的指令只能为：jump，branch，ret三个指令，不考虑ret的情况，块A的转移无非两种情况：

第一种，如果jump到后继块B，那么直接在jump之前赋值即可，具体的赋值是搜索它后继的块(事实上可以直接通过jump找到)，找到来自它的phi指令，然后在A的后面对phi的getAns进行phcopy。它不需要增加辅助块。因此不需要设置修改目标块的操作。

phiCopy是个什么指令，它能存储多个吗？我觉得没有必要，反正是要拆开成move的。

第二，如果brachC或者d，那么检查自己的两个块的phi，看看是否有phi(如果有的话，根据phi的性质，必然存在一个来自A块的value，注意，如果是constant的话，需要检查一下是否是未定义，是的话直接赋值没有任何意义)。如果有，那么就新开一个块，更改指向关系，然后在这个新块里面插入pcopy指令。如果没有的话，当然就没有必要新开了

删除phi指令应该在什么时候执行呢？事实上，遍历函数所有块之后，我们就可以再过一遍块，把phi指令都删掉，只留下copy

### pcopy - > move

pcopy是一个并行的move，就像phi是一个并行的phi

但是phi的并行又是怎么样的呢？

## 寄存器分配

之前在mips生成的时候，为了方便，我一直用的是全部把数据存到内存中。

这样的效率是十分低下的。
