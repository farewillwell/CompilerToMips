# 代码优化

竞速排序最后一个点t了。。

必须优化了这下。。

## 乘除优化

### 常数优化：将常数的运算全算出来

#### 在哪里优化？

### 变量和常量计算

如果对于一个乘法mulExp，，其factor序列为a1,a2...an若前ai个均为常数，则这前ai个可以化简为一个常数

如果其中有一个0，则整个就是0

### 乘法优化

#### constant - constant

不生成指令，直接计算出来结果之后存到相应内存中

包括其他指令在内也一样

#### constant - x

通过shift比较计算

#### x - x

老老实实算吧

#### 除法优化

如果除的数是常数且为2的幂次，可以转化为sll

## CFG

首先解决的是跳转问题

比如在

```
if(a>1)
{
 b=b+1;
 return 0;
}
```

这个代码中，我会生成:

```
b1:
  ret i32 1
  br label %b3
b2:
  ret i32 2
  br label %b3
```

这种形式的，这显然是会错误估计支配边界的。

因此，我们做一个检查，对于一个block，如果遇到了一个离开指令，那么删除后面所有的代码。

### mem2reg

对于全局变量，我们不做这个优化。我们的 mem2reg 只需要对局部的 `int` 类型的变量进行处理

而一定要排除其他的干扰，不然会出现很多错误

![image-20231129133150807](D:\A大三课程资料\编译\Compile_mips\images\image-20231129133150807.png)

现在来理解下这个算法：

F是做了一个记录，记录哪些已经插过phi了，一个块对一个变量插一个就好了

假定defs(v)是所有定义了变量v的块。这个和初始的W是一个意思

W是所有定义(修改该值）的块，加上后代表目前还没有考虑到这个

接下来对于所有修改该值的块，如果还有没有考虑到的，那么就开始考虑这个，同时从W中移除

对于这个块的所有支配边界，这个变量的值可能会被其他块的这个量影响，所以要插phi(这个phi的来源值是？)，同时标记这个块已经被这个变量插过了。当然，phi指令本身就是一个对变量赋值的，所以插入后这个指令也要算作defs(v)的，就是w

**注意，虽然可能一个块没有涉及到一个变量，但是经过它的后续都有可能涉及到这个变量，所以插入phi是理所当然的**。

刚才我们已经完成了df的求解，得到了每一个块的支配边界。但是注意，我们仅仅完成了块的。

和变量有关的是一点没碰啊。。。

同时，发现这里很多东西都是跨块的。如果再把一堆东西都放到函数里面，就太复杂了，这个功能单独拿出来执行即可。

注意，重命名，什么的都是针对的变量，这个变量不是llvmValue，就是不是%那个东西，而是在源程序里的那个 int a什么的

(数组在每个位置上的使用，难以分析，我们选择只分析单一变量，也就是说正常alloca数组)

而int a这样的localVar会在什么地方被声明呢？显然就是alloca那里。在什么地方定义呢？有=就算，就是store

### 算法实现

W用什么数据结构？每次单独拿一个出来？用Linklist不错

Y插入v的phi，那么来源是什么？我怎么知道是哪些基本块？

一开始是不知道的，所以需要先存起来。

### 功能构成

这里还要再在func里面把功能教给func吗？我觉得直接把东西专门拿出来到一个类里面实现是比较好的

alloca ： 代表一个变量(不define)

load : use值，add什么的算use吗，算，但是都需要load专门拿出来，因此load是必须的。

store : define 值

### 变量重命名

什么叫reachingDef? 就是一个变量在这里，它所代表的值。

比如store 一个值x进到一个指针，这个指针代表变量a，那么这里它的到达定义就是x了，把所有从a里store都算作load即可

激动人心的时刻来了！！

![](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150734468.png)

更新到达定义，v是变量，i是指令。

(in-place，原地)

沿着v的定义链搜索，知道我们找到了最近的支配i的定义，然后用这个定义更新v的到达定义

先用将当前的到达定义赋值给r，当r的定义不支配语句i的时候



![image-20231129150035982](D:\A大三课程资料\编译\Compile_mips\images\image-20231129150035982.png)



注意，更换value的时候，要记得把其中的user关系更换。

### bug

phi缺元素问题

```
PHINode should have one entry for each predecessor of its parent basic block!
  %V45 = phi i32 [ %V44, %b3 ]
```

比如上面这个

问题在于phi插是插了，但是填写的不够全.

```java
for (BasicBlock next : block.next) {
            for (Instr instr : next.instrList) {
                if (instr instanceof PhiInstr) {
                    if (!reachDefs.containsKey(((PhiInstr) instr).tieValue)) {
                        continue;
                    }
                    if (reachDefs.get(((PhiInstr) instr).tieValue).empty()) {
                        continue;
                    }
                    Value newValue = reachDefs.get(((PhiInstr) instr).tieValue).peek();
                    ((PhiInstr) instr).refill(newValue, block);
                }
            }
        }
```

我们回填栈的逻辑是：

### 新增变量命名问题：

在优化时，默认在main里面。但是别忘了优化可是对所有函数负责的。

因此新插入phi的时候可能会重复命名变量

解决:在phi指令插入的时候名字改成%V1_Phi,就是后面加个p的意思

幸好没有用方法插入phi，而是直接用容器内置方法插的。

## 寄存器分配

之前在mips生成的时候，为了方便，我一直用的是全部把数据存到内存中。
