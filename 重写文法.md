# 重写文法

## 题目要求

```
1）按词法分析识别单词的顺序，按行输出每个单词的信息（要求同词法分析作业，对于预读的情况不能输出）。
   形如： 单词类别码 单词的字符/字符串形式(中间仅用一个空格间隔)
2）在文法中出现（除了<BlockItem>, <Decl>, <BType> 之外）的语法分析成分分析结束前，另起一行输出当前语法成分的名字，形如“<Stmt>”（注：未要求输出的语法成分仍需要进行分析，但无需输出）
```

因此我们可以删除这几种语法分析成分，防止冗余

## 错误处理

在语法分析阶段，需要在检测词法错误的基础上，进一步检测语法错误，包括以下几种类型。

所以要预留这些的接口

| 错误类型        | 错误类别码 | 解释                                           | 对应文法                                                     |
| :-------------- | :--------- | :--------------------------------------------- | :----------------------------------------------------------- |
| 缺少分号        | i          | 报错行号为分号**前一个非终结符**所在行号。     | \<Stmt>,\<ConstDecl>及\<VarDecl>中的';’                      |
| 缺少右小括号    | j          | 报错行号为右小括号**前一个非终结符**所在行号。 | 函数调用(\<UnaryExp>)、函数定义(\<FuncDef>)及\<Stmt>中的')’  |
| 缺少右中括号’]’ | k          | 报错行号为右中括号**前一个非终结符**所在行号.  | 数组定义(\<ConstDef>,\<VarDef>,\<FuncFParam>)和使用(\<LVal>)中的']’ |

需要重写文法，消除左递归，来方便写编译器

## 重写文法

需要考虑的是：

- 防止超长的函数
- 防止多余的函数
- 防止多余的节点

原则:

- 删除<BlockItem>, <Decl>, <BType>
- 为了防止超长函数而设置的辅助节点，可以在设置输出的时候避免输出本身的语义类型

同时要注意的是，和往届的不完全一样了，比如少了while多了for啥的

需要挨个对照一遍

```java
CompUnit  ==>  {ConstDecl | VarDecl} {FuncDef} MainFuncDef
    
ConstDecl ==> 'const' 'int' ConstDef { ',' ConstDef } ';'  
    //error i: 可能缺少分号
ConstDef ==> Indent {'[' ConstExp ']'} '=' ConstInitVal
    //error b: 重复定义const变量； 
    //error k: cosnt数组定义中缺少右中括号
ConstInitVal ==> ConstExp | '{' [ConstInitVal {',' ConstInitVal}]'}'


VarDecl   ==> 'int' VarDef {',' VarDef} ';'
    //error i: 可能缺少分号
VarDef  ==>  Ident {'['  ConstExp  ']'} ['='  InitVal]
	//error b: 重复定义变量； 
    //error k: 数组定义中缺少右中括号
InitVal ==>  Exp | '{' [InitVal {',' InitVal}]'}'
 
    
    
FuncDef  ==>  FuncType Ident '(' [FuncFormalParams] ')' Block
    //error b: 重复定义函数
    //error g: 有返回值的函数最后一句缺少return
    //error j: 缺少右小括号
FuncType ==> 'void' | 'int'
MainFuncDef  ==>  'int' 'main' '('  ')' Block
    //error b: 重复定义函数
    //error g: 有返回值的函数最后一句缺少return
    //error j: 缺少右小括号
FuncFParams  ==>  FuncFParam {',' FuncFParam}
FuncFParam  ==> 'int' Indent ['[' ']'  {'[' ConstExp ']'}]
    //gerror b: 形参名重复定义
    //error k: 对于数组形参缺少右中括号
FuncRParams → Exp { ',' Exp } 
Block ==> '{' {VarDecl | ConstDecl | Stmt} '}'   
    

    
Stmt ==> AssignStmt | ExpStmt | BlockStmt | IfStmt | ForStmt | BreakStmt | CReturnStmt | GetIntStmt | PrintfStmt
AssignStmt ==> LVal '=' Exp ';'
    //error h: LVal不可以是常量
    //error i: 可能缺少分号
ExpStmt ==> [Exp] ';'
    //error i: 可能缺少分号
BlockStmt ==> block
IfStmt ==> 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
    //error j: 缺少右小括号
BigForStmt ==>  'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt
    //error 除了forstmt中的错误赋值之外不会有任何错误
BreakStmt ==> 'break' ';'
    //error i: 可能缺少分号
    //error m: 循环中可能缺少break语句
ContinueStmt ==> 'continue' ';'
    //error i: 可能缺少分号
    //error m: 循环中可能缺少continue语句
ReturnStmt ==> 'return' [Exp] ';'
    //error f: 无返回值的函数有return exp
    //error i: 可能缺少分号
GetIntStmt ==> LVal '=' 'getint''('')'';'
    //error h: LVal不可以是常量
    //error i: 可能缺少分号
    //error j: 可能缺少右小括号
PrintfStmt ==> 'printf''('FormatString{','Exp}')'';'
    //error i: 可能缺少分号
    //error j: 可能缺少右小括号
    //error l: 格式字符与表达式个数不匹配
ForStmt → LVal '=' Exp

LVal ==> Ident {'[' Exp ']'}
	//error c: 使用未定义的名字
	//error k: 缺少右中括号
PrimaryExp ==> '(' Exp ')' | LVal | Number
UnaryExp ==> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
    //error c: 可能使用未定义的名字（函数调用中） 
    //error d: 函数调用时形参和实参的个数不匹配
    //error e: 函数调用时参数类型不匹配
    //error j: 可能缺少右小括号
MulExp ==> UnaryExp {('*' | '/' | '%') UnaryExp}  //注意归约
AddExp ==> MulExp {('+' | '-') MulExp} //注意归约
RelExp ==> AddExp {('<' | '>' | '<=' | '>=') AddExp} //注意归约
EqExp ==> RelExp {('==' | '!=') RelExp} //注意归约
LAndExp ==> EqExp {'&&' EqExp} //注意归约
LOrExp ==>  LAndExp {'||' LAndExp} //注意归约
Cond ==> LorExp
ConstExp ==> AddExp
Exp ==> AddExp
    
UnaryOp ==> '+' | '-' | '!'
Number ==> IntConst

//下面的语法单元不单独建类
FormatString ==> '"'{Char}'"' 
	//error a: 格式字符串中有非法字符
Char ==> FormatChar | NormalChar
FormatChar ==> %d
NormalChar ==> 十进制编码为32,33,40-126的ASCII字符，'\'（编码92）出现当且仅当为'\n'
```

### 文法建类

##### exp类

AddExp，

Cond，

ConstExp，

EqExp，

Exp，

LAndExp，

LOrExp，

LVal，

MulExp，

Number，**千万注意，number不是终结符**

PrimaryExp，

RelExp，

UnaryExp，

UnaryOp

ForExp

##### func类

FuncDef，

FuncFormalParam，

FuncFormalParams，

FuncRealParams，

FuncType，

MainFuncDef

##### stmt类

AssignStmt，

BlockStmt，

BreakStmt，

ContinueStmt，

ExpStmt，

GetIntStmt，

IfStmt，

PrintfStmt，

ReturnStmt，

Stmt，

WhileStmt

##### 量定义相关

ConstDecl，

ConstDef，

ConstInitVal，

InitVal，

VarDecl，

VarDef

##### 单独成类

Block，

CompUnit，

TokenNode

### 文法输出

犯了很大错误的一点是

解读的时候是按照改写之后的非左递归文法写的，

但是实际上让你实现的文法还是原本的文法

例如改写后的这个

```
AddExp ==> MulExp {('+' | '-') MulExp} //注意归约
```

实际上，输出的时候应该输出：

```
AddExp → MulExp | AddExp ('+' | '−') MulExp 
```



